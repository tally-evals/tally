---
title: Normalization
description: Convert raw metric values into normalized scores.
---

import { PropertyTable } from '@/components/PropertyTable';

# Normalization

Normalizers convert raw metric values into normalized scores.

## Import

```ts
import {
  createMinMaxNormalizer,
  createZScoreNormalizer,
  createThresholdNormalizer,
  createLinearNormalizer,
  createOrdinalMapNormalizer,
  createIdentityNormalizer,
  createCustomNormalizer,
  applyNormalization,
  resolveContext,
  computeDistributionStats,
  computeRange,
  clearContextCache,
  getCachedContext,
} from 'tally/normalization';
```

### Example

```ts
import { defineBaseMetric, createSingleTurnLLM } from 'tally';
import { createMinMaxNormalizer } from 'tally/normalization';
import { google } from '@ai-sdk/google';

const base = defineBaseMetric<number>({
  name: 'answerRelevance',
  valueType: 'number',
});

const answerRelevance = createSingleTurnLLM({
  base,
  provider: google('models/gemini-2.5-flash-lite'),
  prompt: { instruction: 'Score relevance 0-5.', variables: [] as const },
  normalization: {
    default: createMinMaxNormalizer({ min: 0, max: 5, clip: true }),
  },
});
```

### `createMinMaxNormalizer()`

<PropertyTable
  content={[
    { name: 'min', type: 'number', description: 'Minimum value in the range.' },
    { name: 'max', type: 'number', description: 'Maximum value in the range.' },
    { name: 'clip', type: 'boolean', description: 'Whether to clip output to [0,1].', isOptional: true },
    {
      name: 'direction',
      type: "'higher' | 'lower'",
      description: 'Preferred direction for scoring.',
      isOptional: true,
    },
  ]}
/>

### `createZScoreNormalizer()`

<PropertyTable
  content={[
    { name: 'mean', type: 'number', description: 'Mean value for z-score calculation.' },
    { name: 'stdDev', type: 'number', description: 'Standard deviation for z-score calculation.' },
    { name: 'clip', type: 'boolean', description: 'Whether to clip output to [0,1].', isOptional: true },
    {
      name: 'direction',
      type: "'higher' | 'lower'",
      description: 'Preferred direction for scoring.',
      isOptional: true,
    },
    {
      name: 'to',
      type: "'0-1' | '0-100'",
      description: 'Target scale for z-score normalization.',
      isOptional: true,
    },
  ]}
/>

### `createThresholdNormalizer()`

<PropertyTable
  content={[
    { name: 'threshold', type: 'number', description: 'Threshold value.' },
    {
      name: 'above',
      type: 'number',
      description: 'Score for values >= threshold.',
      isOptional: true,
      defaultValue: '1.0',
    },
    {
      name: 'below',
      type: 'number',
      description: 'Score for values < threshold.',
      isOptional: true,
      defaultValue: '0.0',
    },
  ]}
/>

### `createLinearNormalizer()`

<PropertyTable
  content={[
    { name: 'slope', type: 'number', description: 'Slope of the linear transformation.' },
    { name: 'intercept', type: 'number', description: 'Intercept of the linear transformation.' },
    {
      name: 'clip',
      type: '[number, number]',
      description: 'Optional clamp range.',
      isOptional: true,
    },
    {
      name: 'direction',
      type: "'higher' | 'lower'",
      description: 'Preferred direction for scoring.',
      isOptional: true,
    },
  ]}
/>

### `createOrdinalMapNormalizer()`

<PropertyTable
  content={[
    {
      name: 'map',
      type: 'Record<string | number, number>',
      description: 'Mapping of ordinal values to normalized scores.',
    },
  ]}
/>

### `createIdentityNormalizer()`

No options.

### `createCustomNormalizer()`

<PropertyTable
  content={[
    {
      name: 'normalize',
      type: '(value: T, args: { context: ScoringContext; metric: MetricDef<T, MetricContainer> }) => Score',
      description: 'Custom normalization function (must return a Score in [0,1]).',
    },
  ]}
/>

## Low-level utilities

These are intended for **manual normalization or custom pipelines**. Most users wonâ€™t need them.

### `applyNormalization()`

<PropertyTable
  content={[
    { name: 'value', type: 'T', description: 'Raw metric value to normalize.' },
    {
      name: 'normalizerSpec',
      type: 'NormalizerSpec<T, ScoringContext> | NormalizeToScore<T, ScoringContext>',
      description: 'Normalizer specification or function.',
    },
    { name: 'context', type: 'ScoringContext', description: 'Scoring context for normalization.' },
    { name: 'metric', type: 'MetricDef<T, MetricContainer>', description: 'Metric definition (used by custom normalizers).' },
  ]}
/>

### `resolveContext()`

<PropertyTable
  content={[
    { name: 'normalization', type: 'MetricNormalization<T, ScoringContext> | undefined', description: 'Metric normalization config.' },
    { name: 'dataset', type: 'readonly unknown[]', description: 'Full dataset for context resolution.' },
    { name: 'rawValues', type: 'readonly T[]', description: 'Raw values for the metric.' },
    { name: 'metricName', type: 'string', description: 'Metric name used for caching.' },
  ]}
/>

### `computeDistributionStats()`

<PropertyTable
  content={[
    { name: 'rawValues', type: 'readonly number[]', description: 'Raw values to compute mean/stdDev from.' },
  ]}
/>

### `computeRange()`

<PropertyTable
  content={[
    { name: 'rawValues', type: 'readonly number[]', description: 'Raw values to compute min/max from.' },
  ]}
/>

### `clearContextCache()`

No options.

### `getCachedContext()`

<PropertyTable
  content={[
    { name: 'metricName', type: 'string', description: 'Metric name whose context was cached.' },
  ]}
/>

### Example: precompute context once, reuse across runs

```ts
import {
  resolveContext,
  applyNormalization,
  createZScoreNormalizer,
} from 'tally/normalization';

const rawValues = [1, 2, 3, 4, 5];
const normalizer = createZScoreNormalizer({ mean: 3, stdDev: 1, to: '0-1' });

const context = resolveContext({
  metricName: 'latencyScore',
  rawValues,
  normalizer,
});

const score = applyNormalization(2, {
  metricName: 'latencyScore',
  normalizer,
  context,
});
```

