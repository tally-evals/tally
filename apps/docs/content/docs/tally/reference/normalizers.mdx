---
title: Normalizers
description: Convert raw metric values into normalized 0–1 scores.
---

import { PropertyTable } from '@/components/PropertyTable';

# Normalizers

Normalizers convert raw metric values into normalized scores in the 0–1 range. This enables consistent comparison and combination of metrics with different scales.

## Import

```ts
import {
  createMinMaxNormalizer,
  createZScoreNormalizer,
  createThresholdNormalizer,
  createLinearNormalizer,
  createOrdinalMapNormalizer,
  createIdentityNormalizer,
  createCustomNormalizer,
} from '@tally-evals/tally/normalization';
```

---

## Normalizer Factories

### `createMinMaxNormalizer()`

Normalizes values using min-max scaling. Maps a value within a known range to a 0–1 score. Most commonly used for LLM scores (e.g., 1-5 → 0-1).

<PropertyTable
  content={[
    { name: 'min', type: 'number', description: 'Minimum value in the expected range.' },
    { name: 'max', type: 'number', description: 'Maximum value in the expected range.' },
    { name: 'clip', type: 'boolean', description: 'If true, clamps output to [0, 1].', isOptional: true },
    {
      name: 'direction',
      type: "'higher' | 'lower'",
      description: "'higher' = higher values are better (default). 'lower' = lower values are better.",
      isOptional: true,
    },
  ]}
/>

**Example:**
```ts
// LLM scores 0-5 → normalized 0-1
const normalizer = createMinMaxNormalizer({ min: 0, max: 5, clip: true });
```

---

### `createZScoreNormalizer()`

Normalizes values using z-score standardization. Centers values around the mean and scales by standard deviation. Best for distributions where you want to measure deviation from "typical" values.

<PropertyTable
  content={[
    { name: 'mean', type: 'number', description: 'Mean value for z-score calculation.' },
    { name: 'stdDev', type: 'number', description: 'Standard deviation for z-score calculation.' },
    { name: 'clip', type: 'boolean', description: 'If true, clamps output to [0, 1].', isOptional: true },
    {
      name: 'direction',
      type: "'higher' | 'lower'",
      description: 'Preferred direction for scoring.',
      isOptional: true,
    },
    {
      name: 'to',
      type: "'0-1' | '0-100'",
      description: 'Target scale for output.',
      isOptional: true,
    },
  ]}
/>

**Example:**
```ts
// Normalize latency relative to typical values
const normalizer = createZScoreNormalizer({
  mean: 150,
  stdDev: 50,
  direction: 'lower', // Lower latency is better
});
```

---

### `createThresholdNormalizer()`

Converts numeric values to binary scores based on a threshold. Returns one score for values at or above the threshold, another for values below.

<PropertyTable
  content={[
    { name: 'threshold', type: 'number', description: 'Threshold value for comparison.' },
    {
      name: 'above',
      type: 'number',
      description: 'Score for values >= threshold.',
      isOptional: true,
      defaultValue: '1.0',
    },
    {
      name: 'below',
      type: 'number',
      description: 'Score for values < threshold.',
      isOptional: true,
      defaultValue: '0.0',
    },
  ]}
/>

**Example:**
```ts
// Binary pass/fail at 0.7 threshold
const normalizer = createThresholdNormalizer({ threshold: 0.7 });
```

---

### `createLinearNormalizer()`

Applies a linear transformation (slope + intercept) to values. Useful for custom scaling when min-max isn't appropriate.

<PropertyTable
  content={[
    { name: 'slope', type: 'number', description: 'Slope of the linear transformation.' },
    { name: 'intercept', type: 'number', description: 'Intercept of the linear transformation.' },
    {
      name: 'clip',
      type: '[number, number]',
      description: 'Optional clamp range [min, max].',
      isOptional: true,
    },
    {
      name: 'direction',
      type: "'higher' | 'lower'",
      description: 'Preferred direction for scoring.',
      isOptional: true,
    },
  ]}
/>

**Example:**
```ts
// Custom linear scaling
const normalizer = createLinearNormalizer({
  slope: 0.2,
  intercept: 0,
  clip: [0, 1],
});
```

---

### `createOrdinalMapNormalizer()`

Maps ordinal (categorical) values to numeric scores. Use this for string/enum metrics like "Poor", "Fair", "Good", "Excellent".

<PropertyTable
  content={[
    {
      name: 'map',
      type: 'Record<string, number>',
      description: 'Mapping from ordinal values to scores in [0, 1].',
    },
  ]}
/>

**Example:**
```ts
// Map quality grades to scores
const normalizer = createOrdinalMapNormalizer({
  map: {
    'Poor': 0,
    'Fair': 0.33,
    'Good': 0.67,
    'Excellent': 1,
  },
});
```

---

### `createIdentityNormalizer()`

Returns the raw value unchanged. Use this when your metric already produces values in the 0–1 range. For booleans, converts `true` → 1 and `false` → 0.

No options required.

**Example:**
```ts
const normalizer = createIdentityNormalizer();
```

---

### `createCustomNormalizer()`

Creates a normalizer with custom logic. Use this when built-in normalizers don't fit your use case.

<PropertyTable
  content={[
    {
      name: 'normalize',
      type: '(value: T, args: { context: C; metric: MetricDef }) => Score',
      description: 'Custom function that returns a Score in [0, 1].',
    },
  ]}
/>

**Example:**
```ts
// Logarithmic normalization for response length
const normalizer = createCustomNormalizer({
  normalize: (value) => {
    const maxLength = 1000;
    return Math.min(1, Math.log(value + 1) / Math.log(maxLength + 1));
  },
});
```

---

## Using Normalizers

Attach normalizers to metrics via the `normalization` field or using `withNormalization`:

```ts
import { defineBaseMetric, defineSingleTurnLLM, withNormalization } from '@tally-evals/tally';
import { createMinMaxNormalizer } from '@tally-evals/tally/normalization';
import { google } from '@ai-sdk/google';

// Option 1: In the base metric
const base = defineBaseMetric({
  name: 'quality',
  valueType: 'number',
  normalization: {
    normalizer: createMinMaxNormalizer({ min: 0, max: 5, clip: true }),
  },
});

// Option 2: Using withNormalization
const baseMetric = defineBaseMetric({
  name: 'quality',
  valueType: 'number',
});

const normalizedBase = withNormalization({
  metric: baseMetric,
  normalizer: createMinMaxNormalizer({ min: 0, max: 5, clip: true }),
});
```

---

## Calibration

Some normalizers need dataset-level statistics (e.g., actual min/max or mean/stdDev). Use the `calibrate` option:

```ts
const metric = defineSingleTurnCode({
  base: defineBaseMetric({ name: 'latency', valueType: 'number' }),
  compute: ({ data }) => data.latencyMs,
  normalization: {
    normalizer: createMinMaxNormalizer({ min: 0, max: 1000 }),
    // Calibrate from actual data
    calibrate: async ({ rawValues }) => ({
      range: {
        min: Math.min(...rawValues),
        max: Math.max(...rawValues),
      },
    }),
  },
});
```
