---
title: Normalizers
description: Convert raw metric values into normalized scores.
---

import { PropertyTable } from '@/components/PropertyTable';

# Normalizers

Normalizers convert raw metric values into normalized scores.

## Import

```ts
import {
  createMinMaxNormalizer,
  createZScoreNormalizer,
  createThresholdNormalizer,
  createLinearNormalizer,
  createOrdinalMapNormalizer,
  createIdentityNormalizer,
  createCustomNormalizer,
  applyNormalization,
  resolveCalibration,
  computeDistributionStats,
  computeRange,
  createCalibrationCache,
} from 'tally/normalization';
```

### Example

```ts
import { defineBaseMetric, createSingleTurnLLM } from 'tally';
import { createMinMaxNormalizer } from 'tally/normalization';
import { google } from '@ai-sdk/google';

const base = defineBaseMetric<number>({
  name: 'answerRelevance',
  valueType: 'number',
});

const answerRelevance = createSingleTurnLLM({
  base,
  provider: google('models/gemini-2.5-flash-lite'),
  prompt: { instruction: 'Score relevance 0-5.', variables: [] as const },
  normalization: {
    normalizer: createMinMaxNormalizer({ min: 0, max: 5, clip: true }),
  },
});
```

### `createMinMaxNormalizer()`

<PropertyTable
  content={[
    { name: 'min', type: 'number', description: 'Minimum value in the range.' },
    { name: 'max', type: 'number', description: 'Maximum value in the range.' },
    { name: 'clip', type: 'boolean', description: 'Whether to clip output to [0,1].', isOptional: true },
    {
      name: 'direction',
      type: "'higher' | 'lower'",
      description: 'Preferred direction for scoring.',
      isOptional: true,
    },
  ]}
/>

### `createZScoreNormalizer()`

<PropertyTable
  content={[
    { name: 'mean', type: 'number', description: 'Mean value for z-score calculation.' },
    { name: 'stdDev', type: 'number', description: 'Standard deviation for z-score calculation.' },
    { name: 'clip', type: 'boolean', description: 'Whether to clip output to [0,1].', isOptional: true },
    {
      name: 'direction',
      type: "'higher' | 'lower'",
      description: 'Preferred direction for scoring.',
      isOptional: true,
    },
    {
      name: 'to',
      type: "'0-1' | '0-100'",
      description: 'Target scale for z-score normalization.',
      isOptional: true,
    },
  ]}
/>

### `createThresholdNormalizer()`

<PropertyTable
  content={[
    { name: 'threshold', type: 'number', description: 'Threshold value.' },
    {
      name: 'above',
      type: 'number',
      description: 'Score for values >= threshold.',
      isOptional: true,
      defaultValue: '1.0',
    },
    {
      name: 'below',
      type: 'number',
      description: 'Score for values < threshold.',
      isOptional: true,
      defaultValue: '0.0',
    },
  ]}
/>

### `createLinearNormalizer()`

<PropertyTable
  content={[
    { name: 'slope', type: 'number', description: 'Slope of the linear transformation.' },
    { name: 'intercept', type: 'number', description: 'Intercept of the linear transformation.' },
    {
      name: 'clip',
      type: '[number, number]',
      description: 'Optional clamp range.',
      isOptional: true,
    },
    {
      name: 'direction',
      type: "'higher' | 'lower'",
      description: 'Preferred direction for scoring.',
      isOptional: true,
    },
  ]}
/>

### `createOrdinalMapNormalizer()`

<PropertyTable
  content={[
    {
      name: 'map',
      type: 'Record<string | number, number>',
      description: 'Mapping of ordinal values to normalized scores.',
    },
  ]}
/>

### `createIdentityNormalizer()`

No options.

### `createCustomNormalizer()`

<PropertyTable
  content={[
    {
      name: 'normalize',
      type: '(value: T, args: { context: NormalizationContextFor<T>; metric: MetricInfo }) => Score',
      description: 'Custom normalization function (must return a Score in [0,1]).',
    },
  ]}
/>

## Low-level utilities

These are intended for **manual normalization or custom pipelines**. Most users wonâ€™t need them.

### `applyNormalization()`

<PropertyTable
  content={[
    { name: 'value', type: 'T', description: 'Raw metric value to normalize.' },
    {
      name: 'normalizerSpec',
      type: 'NormalizerSpec<T, NormalizationContextFor<T>> | NormalizeToScore<T, NormalizationContextFor<T>>',
      description: 'Normalizer specification or function.',
    },
    { name: 'context', type: 'NormalizationContextFor<T>', description: 'Normalization context (resolved from calibration).' },
    { name: 'metric', type: 'MetricDef<T, MetricContainer>', description: 'Metric definition (used by custom normalizers).' },
  ]}
/>

### `resolveCalibration()`

<PropertyTable
  content={[
    { name: 'normalization', type: 'MetricNormalization<T, NormalizationContextFor<T>> | undefined', description: 'Metric normalization config.' },
    { name: 'dataset', type: 'readonly unknown[]', description: 'Full dataset for context resolution.' },
    { name: 'rawValues', type: 'readonly T[]', description: 'Raw values for the metric.' },
    { name: 'metricName', type: 'string', description: 'Metric name used for per-run caching.' },
    { name: 'cache', type: 'CalibrationCache', description: 'Per-run cache (create once per run).' },
  ]}
/>

### `computeDistributionStats()`

<PropertyTable
  content={[
    { name: 'rawValues', type: 'readonly number[]', description: 'Raw values to compute mean/stdDev from.' },
  ]}
/>

### `computeRange()`

<PropertyTable
  content={[
    { name: 'rawValues', type: 'readonly number[]', description: 'Raw values to compute min/max from.' },
  ]}
/>

### `createCalibrationCache()`

No options.

### Example: precompute context once, reuse across runs

```ts
import {
  resolveCalibration,
  applyNormalization,
  createZScoreNormalizer,
  createCalibrationCache,
} from 'tally/normalization';

const rawValues = [1, 2, 3, 4, 5];
const normalizer = createZScoreNormalizer({ mean: 3, stdDev: 1, to: '0-1' });

const cache = createCalibrationCache();
const context = await resolveCalibration(
  { normalizer },
  [],
  rawValues,
  'latencyScore',
  cache
);

const score = applyNormalization(2, normalizer, context, {
  // minimal fields used by custom normalizers
  name: 'latencyScore',
  valueType: 'number',
});
```

