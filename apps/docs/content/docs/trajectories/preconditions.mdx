---
title: Preconditions
description: Controlling step eligibility and branching logic.
---

Preconditions allow you to create complex, non-linear flows where steps only become available after certain criteria are met.

## Step Satisfied Precondition

The most common precondition is waiting for another step to be completed.

```ts
{
  id: 'step-2',
  instruction: '...',
  preconditions: [
    { type: 'stepSatisfied', stepId: 'step-1' }
  ]
}
```

## Custom Preconditions

You can implement custom logic to check if a step should be eligible. This is useful for checking the state of the agent's database or specific keywords in the conversation.

```ts
{
  id: 'checkout',
  instruction: 'Go to the checkout page.',
  preconditions: [
    {
      type: 'custom',
      name: 'cartNotEmpty',
      evaluate: async (ctx) => {
        const lastMessage = ctx.stepTraces.at(-1)?.agentMessage;
        // Check if agent confirmed item was added
        return lastMessage?.content.includes('added to your cart');
      }
    }
  ]
}
```

## Step Satisfaction

By default, a step is marked as "satisfied" if the user model successfully executes its instruction and the conversation moves forward. You can override this with `isSatisfied`.

```ts
{
  id: 'provide-email',
  instruction: 'Provide your email address.',
  isSatisfied: async (ctx) => {
    const lastUserMsg = ctx.stepTraces.at(-1)?.userMessage;
    // Regex check for email in the last user message
    return /\S+@\S+\.\S+/.test(lastUserMsg.content);
  }
}
```
